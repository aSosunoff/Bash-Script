
# Как устроены `bash-скрипты`

```bash
#!/usr/bin/env bash

# This is a comment

pwd
whoami
```
<details>
	<summary>Детальная информация</summary>
Как устроены `bash-скрипты`

Создайте пустой файл с использованием команды `touch`. В его первой строке нужно указать, какую именно 
оболочку # мы собираемся использовать.
Нас интересует `bash`, поэтому первая строка файла будет такой:

`!/bin/bash`

В других строках этого файла символ решётки используется для обозначения комментариев, 
которые оболочка не обрабатывает. 
Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак 
(эту последовательность называют шебанг) и путь к bash, указывают системе на то, 
что сценарий создан именно для bash.

Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. 
Вот как это выглядит:

Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. 
Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.
</details>

# Сравнение чисел

```bash
#!/usr/bin/env bash

val1=6
if [ $val1 -gt 5 ]; then
    echo "The test value $val1 is greater than 5"
else
    echo "The test value $val1 is not greater than 5"
fi
```
<details>
	<summary>Детальная информация</summary>
Сравнение чисел

В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.

* n1 -eq n2 Возвращает истинное значение, если n1 равно n2.
* n1 -ge n2 Возвращает истинное значение, если n1 больше или равно n2.
* n1 -gt n2 Возвращает истинное значение, если n1 больше n2.
* n1 -le n2 Возвращает истинное значение, если n1 меньше или равно n2.
* n1 -lt n2 Возвращает истинное значение, если n1 меньше n2.
* n1 -ne n2 Возвращает истинное значение, если n1 не равно n2.

В качестве примера опробуем один из операторов сравнения. Обратите внимание на то, что выражение заключено в квадратные скобки.
</details>

# Сравнение строк

```bash
#!/usr/bin/env bash

# Вот пример сравнения строк в сценарии:

user ="likegeeks"
if [$user = $USER]; then
    echo "The user $user  is the current logged in user"
fi

# Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

# Вот как работа с этими операторами выглядит в коде:

val1=text
val2="another text"
if [ $val1 \> "$val2" ]; then
    echo "$val1 is greater than $val2"
else
    echo "$val1 is less than $val2"
fi

# Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:

sort user_list.txt
```
<details>
	<summary>Детальная информация</summary>
Сравнение строк

В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.

str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 Возвращает истину, если строки не идентичны.
str1 < str2 Возвращает истину, если str1 меньше, чем str2.
str1 > str2 Возвращает истину, если str1 больше, чем str2.
-n str1 Возвращает истину, если длина str1 больше нуля.
-z str1 Возвращает истину, если длина str1 равна нулю.
</details>

# Проверки файлов

```bash
#!/usr/bin/env bash

if [ -e user_list.txt ]; then
    echo 1;
else
    echo 2;
fi
```
<details>
	<summary>Детальная информация</summary>
Проверки файлов

Пожалуй, нижеприведённые команды используются в `bash-скриптах` чаще всего. Они позволяют проверять различные условия, касающиеся файлов. Вот список этих команд.

* -d fileПроверяет, существует ли файл, и является ли он директорией.
* -e fileПроверяет, существует ли файл.
* -f file Проверяет, существует ли файл, и является ли он файлом.
* -r fileПроверяет, существует ли файл, и доступен ли он для чтения.
* -s file Проверяет, существует ли файл, и не является ли он пустым.
* -w fileПроверяет, существует ли файл, и доступен ли он для записи.
* -x fileПроверяет, существует ли файл, и является ли он исполняемым.
* file1 -nt file2 Проверяет, новее ли file1, чем file2.
* file1 -ot file2Проверяет, старше ли file1, чем file2.
* -O file Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
* -G fileПроверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

Эти команды, как впрочем, и многие другие рассмотренные сегодня, несложно запомнить. Их имена, являясь сокращениями от различных слов, прямо указывают на выполняемые ими проверки.
</details>

# Вывод сообщений

```bash
#!/usr/bin/env bash

# our comment is here

echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```
<details>
	<summary>Детальная информация</summary>
Вывод сообщений

Для вывода текста в консоль `Linux` применяется команда `echo`. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:

Теперь мы можем выводить поясняющие надписи, используя команду `echo`.
</details>

# Использование переменных

```bash
# Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.

# Нет ничего плохого в исполнении отдельных команд без хранения результатов их работы, но возможности такого подхода весьма ограничены.

# Существуют два типа переменных, которые можно использовать в `bash-скриптах`:

# Переменные среды

# Пользовательские переменны
```
<details>
	<summary>Детальная информация</summary>
Использование переменных
</details>

# Переменные среды

```bash
#!/usr/bin/env bash

echo "Home for the current user id: \$HOME -> $HOME"
```
<details>
	<summary>Детальная информация</summary>
Переменные среды

Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:

Обратите внимание на то, что мы можем использовать системную переменную $HOME в двойных кавычках, это не помешает системе её распознать.
</details>

# Пользовательские переменные

```bash
#!/usr/bin/env bash

name='Alex'
surname='Popov'
echo $name $surname
```
<details>
	<summary>Детальная информация</summary>
Пользовательские переменные

В дополнение к переменным среды, `bash-скрипты` позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.

Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:
</details>

# Подстановка команд

```bash
#!/usr/bin/env bash

mydir=`pwd`
mydir_2=$(pwd)
echo $mydir ' or ' $mydir_2
```
<details>
	<summary>Детальная информация</summary>
Подстановка команд

Одна из самых полезных возможностей `bash-скриптов` — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

С помощью значка обратного апострофа `«`»`
С помощью конструкции `$()`

Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:
</details>

# Математические операции

```bash
#!/usr/bin/env bash

var1=$(( 5 + 5 ))
echo $var1
```
<details>
	<summary>Детальная информация</summary>
Математические операции

Для выполнения математических операций в файле скрипта можно использовать конструкцию вида `$((a+b))`:
</details>

# Управляющая конструкция `if-then`

```bash
#!/usr/bin/env bash

if [ 1 -eq 1 ]; then
    echo true;
else
    echo false;
fi
```
<details>
	<summary>Детальная информация</summary>
Управляющая конструкция `if-then`

В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция `if-then`. В наиболее простом виде она выглядит так:
</details>

# Управляющая конструкция `if-then-else`

```bash
#!/usr/bin/env bash

user=alex
if [ $(grep $user user_list.txt) ]; then
    echo "$user is found of file user_list.txt";
else
    echo 'User is not found';
fi
```
<details>
	<summary>Детальная информация</summary>
Управляющая конструкция `if-then-else`

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией `if-then-else`. Вот как она устроена:

Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке `else`. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после `else`.
</details>


# Циклы for. Перебор простых значений

```bash
#!/usr/bin/env bash

for var in test1 test2 test3; do
	echo "$var"
done
```
<details>
	<summary>Детальная информация</summary>
Циклы for. Перебор простых значений

Оболочка `bash` поддерживает циклы `for`, которые позволяют организовывать перебор последовательностей значений. Вот какова базовая структура таких циклов:

```bash
for var in list do
	команды
done
```

В каждой итерации цикла в переменную var будет записываться следующее значение из списка `list`. В первом проходе цикла, таким образом, будет задействовано первое значение из списка. Во втором — второе, и так далее — до тех пор, пока цикл не дойдёт до последнего элемента.

Обратите внимание на то, что переменная $var сохраняет значение при выходе из цикла, её содержимое можно менять, в целом, работать с ней можно как с любой другой переменной.
</details>

# Управление циклами

```bash
#!/usr/bin/env bash

```
<details>
	<summary>Детальная информация</summary>
Управление циклами

Возможно, после входа в цикл, нужно будет остановить его при достижении переменной цикла определённого значения, которое не соответствует изначально заданному условию окончания цикла. Надо ли будет в такой ситуации дожидаться нормального завершения цикла? Нет конечно, и в подобных случаях пригодятся следующие две команды:

* break
* continue
</details>

# Обработка вывода, выполняемого в цикле

```bash
#!/usr/bin/env bash

for ((i = 0; i < 10; i++)); do
	echo "$i"
done >output_file.txt

```
<details>
	<summary>Детальная информация</summary>
Обработка вывода, выполняемого в цикле

Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер. Делается это с помощью добавления команд обработки вывода после инструкции done.

Например, вместо того, чтобы показывать на экране то, что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:

Оболочка создаст файл `myfile.txt` и перенаправит в этот файл вывод конструкции for. Откроем файл и удостоверимся в том, что он содержит именно то, что ожидается.
</details>

# Пример: поиск исполняемых файлов

```bash
#!/usr/bin/env bash

IFS=:
for folder in $PATH; do
	count_input=10
	echo "$folder "
	for file in $folder/*.exe; do
		if [ $count_input \> 0 ]; then
			# if [ -x "$file" ]; then
			echo "	$file"
			# fi
		else
			break
		fi
		count_input=$(($count_input - 1))
	done
done

```
<details>
	<summary>Детальная информация</summary>
Пример: поиск исполняемых файлов

Давайте воспользуемся тем, что мы уже разобрали, и напишем что-нибудь полезное. Например, если надо выяснить, какие именно исполняемые файлы доступны в системе, можно просканировать все папки, записанные в переменную окружения `PATH`. Весь арсенал средств, который для этого нужен, у нас уже есть, надо лишь собрать всё это воедино:

Такой вот скрипт, небольшой и несложный, позволил получить список исполняемых файлов, хранящихся в папках из `PATH`.
</details>

# Перебор сложных значений

```bash
#!/usr/bin/env bash

for var in "test1 test2" "test3"; do
	echo "$var"
done
```
<details>
	<summary>Детальная информация</summary>
Перебор сложных значений

В списке, использованном при инициализации цикла `for`, могут содержаться не только простые строки, состоящие из одного слова, но и целые фразы, в которые входят несколько слов и знаков препинания.
</details>

# Инициализация цикла списком, полученным из результатов работы команды

```bash
#!/usr/bin/env bash

for line in $(cat file_test.txt); do
	echo "$line"
done

```
<details>
	<summary>Детальная информация</summary>
Инициализация цикла списком, полученным из результатов работы команды

Ещё один способ инициализации цикла `for` заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и получения результатов их работы.

В этом примере задействована команда `cat`, которая читает содержимое файла. Полученный список значений передаётся в цикл и выводится на экран. Обратите внимание на то, что в файле, к которому мы обращаемся, содержится список слов, разделённых знаками перевода строки, пробелы при этом не используются.

Тут надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.

Что, если это совсем не то, что нужно?
</details>

# Разделители полей

```bash
#!/usr/bin/env bash

IFS=$'\n'
for item in $(cat file_test.txt); do
	echo "$item"
done

```
<details>
	<summary>Детальная информация</summary>
Разделители полей

Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется `IFS (Internal Field Separator)` и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:

* Пробел
* Знак табуляции
* Знак перевода строки

Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.

Для того, чтобы решить проблему, можно временно изменить переменную среды `IFS`. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:

```bash
	IFS=$'\n'
```

После добавления этой команды в `bash-скрипт`, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.

Разделителями могут быть и другие символы. Например, выше мы выводили на экран содержимое файла `/etc/passwd`. Данные о пользователях в строках разделены с помощью двоеточий. Если в цикле нужно обрабатывать подобные строки, `IFS` можно настроить так:

```bash
	IFS=:
```
</details>

# Обход файлов, содержащихся в директории

```bash
#!/usr/bin/env bash

for file in $(pwd)/*; do
	if [ -d "$file" ]; then
		echo "$file --> is a directory"
	elif [ -f "$file" ]; then
		echo "$file --> is a file"
	fi
done

```
<details>
	<summary>Детальная информация</summary>
Обход файлов, содержащихся в директории

Один из самых распространённых вариантов использования циклов for в `bash-скриптах` заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.

Например, вот как можно вывести список файлов и папок:

Если вы разобрались с предыдущим материалом из этой серии статей, вам должно быть понятно устройство конструкции `if-then`, а так же то, как отличить файл от папки. Если вам сложно понять вышеприведённый код, перечитайте этот материал.

Обратите внимание на то, как мы инициализируем цикл, а именно — на подстановочный знак «*» в конце адреса папки. Этот символ можно воспринимать как шаблон, означающий: «все файлы с любыми именами». он позволяет организовать автоматическую подстановку имён файлов, которые соответствуют шаблону.

При проверке условия в операторе `if`, мы заключаем имя переменной в кавычки. Сделано это потому что имя файла или папки может содержать пробелы.
</details>

# Циклы for в стиле C

```bash
#!/usr/bin/env bash

for ((i = 0; i < 10; i++)); do
	echo "$i"
done

```
<details>
	<summary>Детальная информация</summary>
Циклы for в стиле C

Если вы знакомы с языком программирования `C`, синтаксис описания `bash-циклов` for может показаться вам странным, так как привыкли вы, очевидно, к такому описанию циклов:

В bash-скриптах можно использовать циклы `for`, описание которых выглядит очень похожим на циклы в стиле `C`, правда, без некоторых отличий тут не обошлось. Схема цикла при подобном подходе выглядит так:

```bash
	for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
```

На `bash` это можно написать так:

```bash
	for (( a = 1; a < 10; a++ ))
```
</details>

# Цикл `while`

```bash
#!/usr/bin/env bash

var1=5
while [ $var1 \> 0 ]; do
	echo $var1
	var1=$(($var1 - 1))
done

```
<details>
	<summary>Детальная информация</summary>
Цикл `while`

Конструкция `for` — не единственный способ организации циклов в `bash-скриптах`. Здесь можно пользоваться и циклами `while`. В таком цикле можно задать команду проверки некоего условия и выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции. Когда условие цикла вернёт ненулевое значение, что означает ошибку, цикл остановится.

Вот схема организации циклов `while`

```bass
	while команда проверки условия
	do
		другие команды
	done
```

На входе в цикл проверяется, больше ли нуля переменная `$var1`. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только `$var1` примет значение 0, цикл прекращается.

Если не модифицировать переменную `$var1`, это приведёт к попаданию скрипта в бесконечный цикл.
</details>

# Вложенные циклы

```bash
#!/usr/bin/env bash

for ((i = 0; i < 5; i++)); do
	echo "$i -"
	for ((j = 0; j < 5; j++)); do
		echo "- $j"
	done
done

```
<details>
	<summary>Детальная информация</summary>
Вложенные циклы

В теле цикла можно использовать любые команды, в том числе — запускать другие циклы. Такие конструкции называют вложенными циклами:
</details>

# Обработка содержимого файла

```bash
#!/usr/bin/env bash

for line in $(cat file_test.txt); do
	echo "$line"
	IFS=$' '
	for item in $line; do
		echo "-- $item"
	done
done

```
<details>
	<summary>Детальная информация</summary>
Обработка содержимого файла

Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла `/etc/passwd`:

В этом скрипте два цикла. Первый проходится по строкам, используя в качестве разделителя знак перевода строки. Внутренний занят разбором строк, поля которых разделены двоеточиями.

Такой подход можно использовать при обработке файлов формата `CSV`, или любых подобных файлов, записывая, по мере надобности, в переменную окружения `IFS` символ-разделитель.
</details>


# Чтение параметров командной строки

```bash
#!/usr/bin/env bash

echo $0
echo $1
echo $2
echo $3

total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```
<details>
	<summary>Детальная информация</summary>
Чтение параметров командной строки

Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:

* $0 — имя скрипта.
* $1 — первый параметр.
* $2 — второй параметр — и так далее, вплоть до переменной $9, в которую попадает девятый параметр.

Запустим сценарий с параметрами:

```bash
	./myscript 5 10 15
```

Обратите внимание на то, что параметры командной строки разделяются пробелами.

Взглянем на ещё один пример использования параметров. Тут мы найдём сумму чисел, переданных сценарию:

Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки. Например, вот скрипт, работающий со строкой:

```bash
	#!/bin/bash
	echo Hello $1, how do you do
```

Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие части этого руководства, ответ вы уже знаете. Заключается он в использовании кавычек.

Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:

```bash
	${10}
```
</details>

# Ввод паролей

```bash
#!/usr/bin/env bash

read -s -p "Enter your password: " pass
echo "Is your password really $pass?"
```
<details>
	<summary>Детальная информация</summary>
Ввод паролей

Иногда то, что вводит пользователь в ответ на вопрос скрипта, лучше на экране не показывать. Например, так обычно делают, запрашивая пароли. Ключ `-s` команды read предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда `read` делает цвет текста таким же, как цвет фона.
</details>

# Чтение данных из файла

```bash
#!/usr/bin/env bash

echo $'\n'
echo 'Read from file test.txt'

cat test.txt | while read line; do
	echo $line
done
```
<details>
	<summary>Детальная информация</summary>
Чтение данных из файла

Команда read может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится. Если нужно получить в скрипте всё содержимое файла, можно, с помощью конвейера, передать результаты вызова команды cat для файла, конструкции `while`, которая содержит команду read (конечно, использование команды cat выглядит примитивно, но наша цель — показать всё максимально просто, ориентируясь на новичков; опытные пользователи, уверены, это поймут).

Напишем скрипт, в котором используется только что описанный подход к чтению файлов.

Тут мы передали в цикл `while` содержимое файла и перебрали все строки этого файла, выводя номер и содержимое каждой из них.
</details>

# Проверка параметров, Подсчёт параметров

```bash
#!/usr/bin/env bash

# Check paramerer
if [ -n "$1" ]; then
	echo "First parameter is ( $1 )"
	echo "The were ( $# ) parameters passed"
	echo "The last parameter is ( ${!#} )"
fi
```
<details>
	<summary>Детальная информация</summary>
Проверка параметров, Подсчёт параметров

Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:

В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная `$#` содержит количество параметров, переданных сценарию при вызове.
</details>

# Захват всех параметров командной строки

```bash
#!/usr/bin/env bash

if [ -n "$1" ]; then
	echo "echo param by a for"
	for item in "$*"; do
		echo "$item"
	done

	echo $'\n'
	echo "echo param by a for"
	for item in "$@"; do
		echo "$item"
	done
fi
```
<details>
	<summary>Детальная информация</summary>
Захват всех параметров командной строки

В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными `$*` и `$@.` Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных параметров.

Переменная `$*` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной `$@` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

Переменная `$*` содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной `$@` они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.
</details>

# Команда shift

```bash
#!/usr/bin/env bash

echo "echo param by a while"
while [ -n "$1" ]; do
	echo $1
	shift
done
```
<details>
	<summary>Детальная информация</summary>
Команда shift

Использовать команду `shift` в `bash-скриптах` следует с осторожностью, так как она, в прямом смысле слова, сдвигает значения позиционных параметров.

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной `$3` становится значением переменной `$2`, значение `$2` переходит в `$1`, а то, что было до этого в `$1`, теряется. Обратите внимание на то, что при этом значение переменной `$0`, содержащей имя скрипта, не меняется.

Воспользовавшись командой `shift`, рассмотрим ещё один способ перебора переданных скрипту параметров:

Скрипт задействует цикл `while`, проверяя длину значения первого параметра. Когда длина станет равна нулю, происходит выход из цикла. После проверки первого параметра и вывода его на экран, вызывается команда `shift`, которая сдвигает значения параметров на одну позицию.

Используя команду `shift`, помните о том, что при каждом её вызове значение переменной `$1` безвозвратно теряется.
</details>

# Ключи командной строки

```bash
#!/usr/bin/env bash

echo "echo param by a while"
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "case -a" ;;
		-r | -y) echo "case -r or -y" ;;
		*) echo "default" ;;
	esac
	shift
done
```
<details>
	<summary>Детальная информация</summary>
Ключи командной строки

Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями.

В этом коде использована конструкция `case`, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «*».
</details>

# Как различать ключи и параметры

```bash
#!/usr/bin/env bash

echo "echo param and kye by a while"
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "Key => -a" ;;
		-b) echo "Key => -b" ;;
		--) shift 
		break ;;
		*) echo "$1 is not an option" ;;
	esac
	shift
done
```
<details>
	<summary>Детальная информация</summary>
Как различать ключи и параметры

Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Эта последовательность — двойное тире (--). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:

Этот сценарий использует команду break для прерывания цикла while при обнаружении в строке двойного тире.

Как видно, когда скрипт, разбирая переданные ему данные, находит двойное тире, он завершает обработку ключей и считает всё, что ещё не обработано, параметрами.
</details>

# Обработка ключей со значениями

```bash
#!/usr/bin/env bash

echo $'\n'
echo "echo param and kye by a while"
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "Key => -a" ;;
		-b) echo "Key => -b" ;;
		--) shift 
		break ;;
		*) echo "$1 is not an option" ;;
	esac
	shift
done

for parap in $@; do
	echo "Param => $parap"
done
```
<details>
	<summary>Детальная информация</summary>
Обработка ключей со значениями

По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. Например, вызов сценария в котором используется подобная возможность, выглядит так:

```bash
	./myscript -a test1 -b -c test2
```
Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры:

В данном примере в конструкции case обрабатываются три ключа. Ключ -b требует наличия дополнительного параметра. Так как обрабатываемый ключ находится в переменной $1, соответствующий ему параметр будет находиться в $2 (тут используется команда shift, поэтому, по мере обработки, всё, что передано сценарию, сдвигается влево). Когда с этим мы разобрались, осталось лишь извлечь значение переменной $2 и у нас будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда shift для того, чтобы следующий ключ попал в $1.
</details>

# Использование стандартных ключей

```bash
#!/usr/bin/env bash

# При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:

# * -a Вывести все объекты.
# * -c Произвести подсчёт.
# * -d Указать директорию.
# * -e Развернуть объект.
# * -f Указать файл, из которого нужно прочитать данные.
# * -h Вывести справку по команде.
# * -i Игнорировать регистр символов.
# * -l Выполнить полноформатный вывод данных.
# * -n Использовать неинтерактивный (пакетный) режим.
# * -o Позволяет указать файл, в который нужно перенаправить вывод.
# * -q Выполнить скрипт в quiet-режиме.
# * -r Обрабатывать папки и файлы рекурсивно.
# * -s Выполнить скрипт в silent-режиме.
# * -v Выполнить многословный вывод.
# * -x Исключить объект.
# * -y Ответить «yes» на все вопросы.

# Если вы работаете в Linux, вам, скорее всего, знакомы многие из этих ключей. Использовав их в общепринятом значении в своих скриптах, вы поможете пользователям взаимодействовать с ними, не беспокоясь о чтении документации.
```
<details>
	<summary>Детальная информация</summary>
Использование стандартных ключей
</details>

# Получение данных от пользователя

```bash
#!/usr/bin/env bash

echo -n "Enter your name: "
read name
echo "Welcome $name"

echo $'\n'
read -p "Enter your name: " first last
echo "Your data for $last $first"

echo $'\n'
read -p "Enter your name: "
echo "Hello $REPLY, welcome to my program"

if read -t 5 -p "Enter your name: "; then
	echo "Hello $name, welcome to my script"
else
	echo "Sorry, to slow!"
fi
```
<details>
	<summary>Детальная информация</summary>
Получение данных от пользователя

Ключи и параметры командной строки — это отличный способ получить данные от того, кто пользуется скриптом, однако в некоторых случаях нужно больше интерактивности.

Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда read.

Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов. После получения данных, эта команда помещает их в переменную:

Обратите внимание на то, что команда `echo`, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей строке.

При вызове read можно указывать и несколько переменных:

Если, вызвав read, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`:

Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду read можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:
</details>


# Стандартные дескрипторы файлов

```bash
# Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

# Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают.

# 0, STDIN — стандартный поток ввода.
# 1, STDOUT — стандартный поток вывода.
# 2, STDERR — стандартный поток ошибок.

# Эти три специальных дескриптора обрабатывают ввод и вывод данных в сценарии.
# Вам нужно как следует разобраться в стандартных потоках. Их можно сравнить с фундаментом, на котором строится взаимодействие скриптов с внешним миром. Рассмотрим подробности о них.
```
<details>
	<summary>Детальная информация</summary>
Стандартные дескрипторы файлов
</details>

# Создание собственного перенаправления вывода

```bash
#!/usr/bin/env bash

exec 3>2_1.txt
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
```
<details>
	<summary>Детальная информация</summary>
Создание собственного перенаправления вывода

Перенаправляя ввод и вывод в сценариях, вы не ограничены тремя стандартными дескрипторами файлов. Как уже говорилось, можно иметь до девяти открытых дескрипторов. Остальные шесть, с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

Назначить дескриптор для вывода данных можно, используя команду exec:
</details>

# Создание дескрипторов файлов для ввода данных

```bash
#!/usr/bin/env bash

exec 6<&0
exec 0< 3_1.txt
while read line; do
	echo $line
done

exec 0<&6
read -p "Are you don new?" answer
case "$answer" in
	y) echo "Goodbye" ;;
	n) echo "Sorry, this is the end";;
esac
```
<details>
	<summary>Детальная информация</summary>
Создание дескрипторов файлов для ввода данных

Перенаправить ввод в скрипте можно точно так же, как и вывод. Сохраните STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных.

После окончания чтения файла можно восстановить STDIN и пользоваться им как обычно

В этом примере дескриптор файла 6 использовался для хранения ссылки на STDIN. Затем было сделано перенаправление ввода, источником данных для STDIN стал файл. После этого входные данные для команды read поступали из перенаправленного STDIN, то есть из файла.

После чтения файла мы возвращаем STDIN в исходное состояние, перенаправляя его в дескриптор 6. Теперь, для того, чтобы проверить, что всё работает правильно, скрипт задаёт пользователю вопрос, ожидает ввода с клавиатуры и обрабатывает то, что введено.
</details>

# STDIN

```bash
# 0, STDIN — стандартный поток ввода.
```
<details>
	<summary>Детальная информация</summary>
STDIN

STDIN — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура. Когда в сценариях используют символ перенаправления ввода — <, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.

Многие команды bash принимают ввод из STDIN, если в командной строке не указан файл, из которого надо брать данные. Например, это справедливо для команды cat.

Когда вы вводите команду cat в командной строке, не задавая параметров, она принимает ввод из STDIN. После того, как вы вводите очередную строку, cat просто выводит её на экран.
</details>

# STDOUT

```bash
#!/usr/bin/env bash

# 1, STDOUT — стандартный поток вывода.

pwd >> myfile

ls –l xfile > myfile
```
<details>
	<summary>Детальная информация</summary>
STDOUT

STDOUT — стандартный поток вывода оболочки. По умолчанию это — экран. Большинство bash-команд выводят данные в STDOUT, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда >>.

Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:

Пока всё хорошо, но что если попытаться выполнить что-то вроде показанного ниже, обратившись к несуществующему файлу xfile, задумывая всё это для того, чтобы в файл myfile попало сообщение об ошибке.

При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но мы-то хотели, чтобы сообщения об ошибках попали в файл. Что делать? Ответ прост — воспользоваться третьим стандартным дескриптором.
</details>

# STDERR

```bash
#!/usr/bin/env bash

# 2, STDERR — стандартный поток ошибок.
```
<details>
	<summary>Детальная информация</summary>
STDERR

STDERR представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает STDOUT, именно поэтому при возникновении ошибки мы видим сообщение на экране.

Итак, предположим, что надо перенаправить сообщения об ошибках, скажем, в лог-файл, или куда-нибудь ещё, вместо того, чтобы выводить их на экран.
</details>

# Перенаправление потока ошибок

```bash
#!/usr/bin/env bash

ls -l xfile 2>myfile
cat ./myfile
```
<details>
	<summary>Детальная информация</summary>
Перенаправление потока ошибок

Как вы уже знаете, дескриптор файла STDERR — 2. Мы можем перенаправить ошибки, разместив этот дескриптор перед командой перенаправления:

Сообщение об ошибке теперь попадёт в файл myfile.
</details>

# Перенаправление потоков ошибок и вывода

```bash
#!/usr/bin/env bash

ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
```
<details>
	<summary>Детальная информация</summary>
Перенаправление потоков ошибок и вывода

При написании сценариев командной строки может возникнуть ситуация, когда нужно организовать и перенаправление сообщений об ошибках, и перенаправление стандартного вывода. Для того, чтобы этого добиться, нужно использовать команды перенаправления для соответствующих дескрипторов с указанием файлов, куда должны попадать ошибки и стандартный вывод:

Оболочка перенаправит то, что команда ls обычно отправляет в STDOUT, в файл correctcontent благодаря конструкции 1>. Сообщения об ошибках, которые попали бы в STDERR, оказываются в файле errorcontent из-за команды перенаправления 2>.

Если надо, и STDERR, и STDOUT можно перенаправить в один и тот же файл, воспользовавшись командой &>:

После выполнения команды то, что предназначено для STDERR и STDOUT, оказывается в файле content.
</details>

# Временное перенаправление вывода

```bash
#!/usr/bin/env bash

#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
```
<details>
	<summary>Детальная информация</summary>
Временное перенаправление вывода

В скрипте можно перенаправить вывод отдельной строки в STDERR. Для того, чтобы это сделать, достаточно использовать команду перенаправления, указав дескриптор STDERR, при этом перед номером дескриптора надо поставить символ амперсанда (&):

Если запустить скрипт, обе строки попадут на экран, так как, как вы уже знаете, по умолчанию ошибки выводятся туда же, куда и обычные данные.

Запустим скрипт так, чтобы вывод STDERR попадал в файл.

```bash
./myscript 2> myfile
```

Как видно, теперь обычный вывод делается в консоль, а сообщения об ошибках попадают в файл
</details>

# Перенаправление ввода в скриптах

```bash
#!/usr/bin/env bash

exec 1>1_2.txt
echo "This is a test of redirecting all output"
```
<details>
	<summary>Детальная информация</summary>
Перенаправление ввода в скриптах

Для перенаправления ввода можно воспользоваться той же методикой, которую мы применяли для перенаправления вывода. Например, команда exec позволяет сделать источником данных для STDIN какой-нибудь файл

Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл myfile, а не обычный STDIN. Посмотрим на перенаправление ввода в действии

В одном из предыдущих материалов вы узнали о том, как использовать команду read для чтения данных, вводимых пользователем с клавиатуры. Если перенаправить ввод, сделав источником данных файл, то команда read, при попытке прочитать данные из STDIN, будет читать их из файла, а не с клавиатуры.

Некоторые администраторы Linux используют этот подход для чтения и последующей обработки лог-файлов.
</details>

# Постоянное перенаправление вывода

```bash
#!/usr/bin/env bash

exec 1>1_1.txt
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"

exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
```
<details>
	<summary>Детальная информация</summary>
Постоянное перенаправление вывода

Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову `echo` неудобно. Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой `exec`:

Если просмотреть файл, указанный в команде перенаправления вывода, окажется, что всё, что выводилось командами echo, попало в этот файл.

Команду exec можно использовать не только в начале скрипта, но и в других местах

Сначала команда exec задаёт перенаправление вывода из `STDERR` в файл `myerror`. Затем вывод нескольких команд echo отправляется в `STDOUT` и выводится на экран. После этого команда exec задаёт отправку того, что попадает в `STDOUT`, в файл `myfile`, и, наконец, мы пользуемся командой перенаправления в `STDERR` в команде `echo`, что приводит к записи соответствующей строки в файл `myerror`.

Освоив это, вы сможете перенаправлять вывод туда, куда нужно. Теперь поговорим о перенаправлении ввода.
</details>


# Объявление функций

```bash
#!/usr/bin/env bash

# Функцию можно объявить так:

# functionName {
# }

# Или так:

# functionName() {
# }

# Функцию можно вызвать без аргументов и с аргументами.
```
<details>
	<summary>Детальная информация</summary>
Объявление функций
</details>

# Использование команды return

```bash
#!/usr/bin/env bash

function functionTest {
	echo "$1" # arguments are accessible through FunctionTest, echo "$1" # arguments are accessible through FunctionTest, ,...,...
	echo "$2" # arguments are accessible through FunctionTest, echo "$1" # arguments are accessible through FunctionTest, ,...,...
	echo '1 + 1'
	return $[1 + 1]
}

functionTest 1 2
echo "return value from functionTest is => $?"
```
<details>
	<summary>Детальная информация</summary>
Использование команды return

Команда return позволяет задавать возвращаемый функцией целочисленный код завершения. Есть два способа работы с тем, что является результатом вызова функции.

Функции bash можно воспринимать как небольшие фрагменты кода, которые позволяют экономить время и место, избавляя нас от необходимости постоянно вводить с клавиатуры или копировать одни и те же наборы команд. Однако, возможности функций гораздо шире. В частности, речь идёт о передаче им аргументов.

Функции могут использовать стандартные позиционные параметры, в которые записывается то, что передаётся им при вызове. Например, имя функции хранится в параметре `$0`, первый переданный ей аргумент — в `$1`, второй — в `$2`, и так далее. Количество переданных функции аргументов можно узнать, обратившись к переменной `$#`.
</details>

# Запись вывода функции в переменную

```bash
#!/usr/bin/env bash

function test {
	echo $[10 + 9]
}
result=$(test)
echo $result
```
<details>
	<summary>Детальная информация</summary>
Запись вывода функции в переменную

Ещё один способ возврата результатов работы функции заключается в записи данных, выводимых функцией, в переменную. Такой подход позволяет обойти ограничения команды return и возвращать из функции любые данные
</details>

# Глобальные переменные. Локальные переменные

```bash
#!/usr/bin/env bash

# Глобальные переменные
function concatFn {
	text="$text XXX"
}

read -p "Enter text: " text
concatFn
echo $text

# Локальные переменные
function concatFn {
	local t="$1 XXX"
	echo $t
}

read -p "Enter text: " text
r=$(concatFn $text)
echo $r
```
<details>
	<summary>Детальная информация</summary>
Глобальные переменные. Локальные переменные

Глобальные переменные — это переменные, которые видны из любого места bash-скрипта. Если вы объявили глобальную переменную в основном коде скрипта, к такой переменной можно обратиться из функции.

Почти то же самое справедливо и для глобальных переменных, объявленных в функциях. Обращаться к ним можно и в основном коде скрипта после вызова функций.

По умолчанию все объявленные в скриптах переменные глобальны. Так, к переменным, объявленным за пределами функций, можно без проблем обращаться из функций

Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово `local` перед именем переменной:

Если за пределами функции есть переменная с таким же именем, это на неё не повлияет. Ключевое слово local позволяет отделить переменные, используемые внутри функции, от остальных переменных.
</details>

# Передача функциям массивов в качестве аргументов

```bash
#!/usr/bin/env bash

function text {
	echo "Parameter $@"
	local arr=$@
	echo ${arr[*]}
}
myArr=(1 2 3 4 5)
echo "The original array is: ${myArr[*]}"
text ${myArr[*]}
```
<details>
	<summary>Детальная информация</summary>
Передача функциям массивов в качестве аргументов

Попробуем передать функции в качестве аргумента массив. Сразу хочется сказать, что работать такая конструкция будет неправильно:

```bash
#!/bin/bash
function myfunc {
	echo "The parameters are: $@"
	arr=$1
	echo "The received array is ${arr[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
myfunc $myarray
```

Как видно из примера, при передаче функции массива, она получит доступ лишь к его первому элементу.

Для того, чтобы эту проблему решить, из массива надо извлечь имеющиеся в нём данные и передать их функции как самостоятельные аргументы. Если надо, внутри функции полученные ей аргументы можно снова собрать в массив:


</details>

# Создание и использование библиотек

```bash
#!/usr/bin/env bash
. myfunc.sh

# Создание и использование библиотек
echo $(text)
```
<details>
	<summary>Детальная информация</summary>
Создание и использование библиотек

Итак, теперь вы знаете, как писать функции и как вызывать их в том же скрипте, где они объявлены. Что если надо использовать функцию, тот блок кода, который она собой представляет, в другом скрипте, не используя копирование и вставку?

Оболочка bash позволяет создавать так называемые библиотеки — файлы, содержащие функции, а затем использовать эти библиотеки в любых скриптах, где они нужны.

Ключ к использованию библиотек — в команде source. Эта команда используется для подключения библиотек к скриптам. В результате функции, объявленные в библиотеке, становятся доступными в скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других скриптов.

У команды source есть псевдоним — оператор «точка». Для того, чтобы подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:

```bash
# myfunc.sh
#!/usr/bin/env bash

# Создание и использование библиотек
function text {
	echo $[1 + 2]
}
```
</details>

# 

```bash
#!/usr/bin/env bash

# Создание и использование библиотек
function text {
	echo $[1 + 2]
}
```

