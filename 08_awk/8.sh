#!/usr/bin/env bash

awk 'BEGIN{print ARGC,ARGV[1]}' myfile

echo $'\n'

awk '
BEGIN{
    print ENVIRON["HOME"]
    print ENVIRON["PATH"]
}'

echo $'\n'

awk 'BEGIN{FS="."; OFS=":"} {print $1,$NF}' myfile_2

echo $'\n'

awk '
BEGIN{FS="."}
{print $1, "FNR="FNR, "NR="NR}
END{print "There were",NR,"record processed"}' myfile_2 myfile_2
:<<'END_COMMENT'
# Встроенные переменные: сведения о данных и об окружении

Помимо встроенных переменных, о которых мы уже говорили, существуют и другие, которые предоставляют сведения о данных и об окружении, в котором работает awk:

    * ARGC — количество аргументов командной строки.
    * ARGV — массив с аргументами командной строки.
    * ARGIND — индекс текущего обрабатываемого файла в массиве ARGV.
    * ENVIRON — ассоциативный массив с переменными окружения и их значениями.
    * ERRNO — код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов.
    * FILENAME — имя входного файла с данными.
    * FNR — номер текущей записи в файле данных.
    * IGNORECASE — если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов.
    * NF — общее число полей данных в текущей записи.
    * NR — общее число обработанных записей.

Переменные `ARGC` и `ARGV` позволяют работать с аргументами командной строки. При этом скрипт, переданный awk, не попадает в массив аргументов `ARGV`. Напишем такой скрипт:

```bash
$ awk 'BEGIN{print ARGC,ARGV[1]}' myfile
```
После его запуска можно узнать, что общее число аргументов командной строки — 2, а под индексом 1 в массиве `ARGV` записано имя обрабатываемого файла. В элементе массива с индексом 0 в данном случае будет «awk».

Переменная ENVIRON представляет собой ассоциативный массив с переменными среды. Опробуем её:

```bash
$ awk '
    BEGIN {
        print ENVIRON["HOME"]
        print ENVIRON["PATH"]
    }'
```

Переменные среды можно использовать и без обращения к `ENVIRON`. Сделать это, например, можно так:

```bash
$  echo | awk -v home=$HOME '{print "My home is " home}'
```

Переменная `NF` позволяет обращаться к последнему полю данных в записи, не зная его точной позиции:

```bash
$ awk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd
```

Эта переменная содержит числовой индекс последнего поля данных в записи. Обратиться к данному полю можно, поместив перед `NF` знак `$`.

Переменные `FNR` и `NR`, хотя и могут показаться похожими, на самом деле различаются. Так, переменная `FNR` хранит число записей, обработанных в текущем файле. Переменная `NR` хранит общее число обработанных записей. Рассмотрим пару примеров, передав awk один и тот же файл дважды:

```bash
$ awk 'BEGIN{FS=","}{print $1,"FNR="FNR}' myfile myfile
```

Передача одного и того же файла дважды равносильна передаче двух разных файлов. Обратите внимание на то, что `FNR` сбрасывается в начале обработки каждого файла.

Взглянем теперь на то, как ведёт себя в подобной ситуации переменная NR:

```bash
$ awk '
BEGIN {FS=","}
{print $1,"FNR="FNR,"NR="NR}
END{print "There were",NR,"records processed"}' myfile myfile
```

Как видно, `FNR`, как и в предыдущем примере, сбрасывается в начале обработки каждого файла, а вот NR, при переходе к следующему файлу, сохраняет значение.
END_COMMENT