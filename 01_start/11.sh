#!/usr/bin/env bash

# Вот пример сравнения строк в сценарии:

user ="likegeeks"
if [$user = $USER]; then
    echo "The user $user  is the current logged in user"
fi

# Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

# Вот как работа с этими операторами выглядит в коде:

val1=text
val2="another text"
if [ $val1 \> "$val2" ]; then
    echo "$val1 is greater than $val2"
else
    echo "$val1 is less than $val2"
fi

# Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:

sort user_list.txt
:<<'END_COMMENT'
# Сравнение строк

В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.

	str1 = str2 Проверяет строки на равенство, возвращает истину, если строки идентичны.
	str1 != str2 Возвращает истину, если строки не идентичны.
	str1 < str2 Возвращает истину, если str1 меньше, чем str2.
	str1 > str2 Возвращает истину, если str1 больше, чем str2.
	-n str1 Возвращает истину, если длина str1 больше нуля.
	-z str1 Возвращает истину, если длина str1 равна нулю.

Вот пример сравнения строк в сценарии:

```bash
#!/bin/bash
user ="likegeeks"
if [$user = $USER] then
	echo "The user $user  is the current logged in user"
fi
```

Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

Вот как работа с этими операторами выглядит в коде:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ] then
	echo "$val1 is greater than $val2"
else
	echo "$val1 is less than $val2"
fi
```

Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:

	./myscript: line 5: [: too many arguments

Для того, чтобы избавиться от этого предупреждения, заключим $val2 в двойные кавычки:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ] then
	echo "$val1 is greater than $val2"
else
	echo "$val1 is less than $val2"
fi
```

Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:

	Likegeeks
	likegeeks

Сохраним его, дав имя myfile, после чего выполним в терминале такую команду:

	sort myfile

Она отсортирует строки из файла так:

	likegeeks
	Likegeeks

Команда sort, по умолчанию, сортирует строки по возрастанию, то есть строчная буква в нашем примере меньше прописной. Теперь подготовим скрипт, который будет сравнивать те же строки:

```bash
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ] then
	echo "$val1 is greater than $val2"
else
	echo "$val1 is less than $val2"
fi
```

Если его запустить, окажется, что всё наоборот — строчная буква теперь больше прописной.

В командах сравнения прописные буквы меньше строчных. Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки, таким образом, зависит от кодов символов.

Команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.
END_COMMENT