#!/usr/bin/env bash

user=alex
if [ $(grep $user user_list.txt) ]; then
    echo "$user is found of file user_list.txt";
else
    echo 'User is not found';
fi
:<<'END_COMMENT'
# Управляющая конструкция `if-then-else`

Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией if-then-else. Вот как она устроена:

	if команда then
		команды
	else
		команды
	fi

Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке else. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после else.

Напишем такой скрипт:

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd then
	echo "The user $user Exists"
else
	echo "The user $user doesn’t exist"
fi
```

Его исполнение пошло по ветке else.

Ну что же, продолжаем двигаться дальше и зададимся вопросом о более сложных условиях. Что если надо проверить не одно условие, а несколько? Например, если нужный пользователь найден, надо вывести одно сообщение, если выполняется ещё какое-то условие — ещё одно сообщение, и так далее. В подобной ситуации нам помогут вложенные условия. Выглядит это так:

	if команда1 then
		команды
	elif команда2 then
		команды
	fi

Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке then, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода.

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd then
	echo "The user $user Exists"
elif ls /home then
	echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

В подобном скрипте можно, например, создавать нового пользователя с помощью команды useradd, если поиск не дал результатов, или делать ещё что-нибудь полезное.
END_COMMENT